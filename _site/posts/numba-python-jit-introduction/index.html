<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jon Cavallie Mester">
<meta name="dcterms.date" content="2023-09-04">

<title>Jon Cavallie Mester - Gotta Go Fast: Speeding Up Python With Numba</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jon Cavallie Mester</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jonmest" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/jon-mester/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Gotta Go Fast: Speeding Up Python With Numba</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Jon Cavallie Mester </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 4, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Python’s charm lies in its simplicity and vibrant ecosystem. But let’s face it: it’s not exactly known for blazing speed. Still, we cling to it, thanks to its ease of use. Sometimes, though, we yearn for both Python’s simplicity and the speed of an F1 car.</p>
<p>Enter Numba, your Python speedster. It’s not a magic wand, but it’s as close as you’ll get to one in the world of Python.</p>
<section id="the-quest-for-speed" class="level2">
<h2 class="anchored" data-anchor-id="the-quest-for-speed">The Quest for Speed</h2>
<p>Python, especially CPython, its most common implementation, is an interpreter. This means it has to do some backstage work before executing your code. It compiles your Python script into bytecode and then gets down to business. While this design choice makes Python accessible and portable, it’s not winning any speed contests.</p>
<p>Then there’s the Global Interpreter Lock (GIL), which makes sure that only one processor thread is in control at any given time. So, even if you have a CPU that’s the envy of your tech-savvy friends, Python might not make the most of it because of the GIL.</p>
<p>Numba is here to save the day by tossing the GIL aside and turning your Python script into machine code. It pulls off this magic trick through a technique known as Just-In-Time (JIT) compilation.</p>
</section>
<section id="jit-vs.-aot-compilation-the-showdown" class="level2">
<h2 class="anchored" data-anchor-id="jit-vs.-aot-compilation-the-showdown">JIT vs.&nbsp;AOT Compilation: The Showdown</h2>
<p>Before we go any further, let’s get theoretical for a moment. Ahead-Of-Time (AOT) compilation is like baking a cake and serving it right away. You write your program, compile it into a binary, and voila! It’s precompiled and ready to roll. But Just-In-Time (JIT) compilation is a bit different. You write your code, distribute it, and the first time your code gets called, it’s compiled on the spot. The second time and beyond, it’s already compiled and running at full throttle.</p>
<p>Why go JIT instead of AOT? Well, for one, you can skip the headache of compiling your code for every platform out there. Plus, you get a speed boost, although there’s a small price to pay during the first code invocation when it’s getting warmed up.</p>
<p>Now, let’s dig into some code to show you what I’m talking about. To follow along, just <code>pip install numba</code>.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numba <span class="im">as</span> nb</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.njit</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> square(x):</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>square(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div id="basic-numba-demo" class="cell-output cell-output-display" data-execution_count="1">
<pre><code>25</code></pre>
<p>A simple declaration of a Numba JIT-compiled function.</p>
</div>
</div>
<p>Admittedly, this is a pretty simple example, and you won’t see your code break the sound barrier here. But what’s important is that <code>@nb.njit</code> decorator. It’s the secret sauce that makes your code faster by <em>completely</em> compiling the function to machine code. It gives you the fastest code,but does not work with all Python code and libraries which we’ll discuss later.</p>
</section>
<section id="speed-showdown" class="level2">
<h2 class="anchored" data-anchor-id="speed-showdown">Speed Showdown</h2>
<p>But enough with the theory. How much faster are we talking? To find out, we’ll use the <code>%timeit</code> magic function in our notebook. It runs the code multiple times and gives us the average execution time, which we want since the very first call of our Numba function will trigger a compilation throwing off any single time measurement. We’ll also wrap the regular Python squaring operation in a function to factor in any function call overhead.</p>
<div id="basic-numba-demo-speed" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit square(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>116 ns ± 3.34 ns per loop (mean ± std. dev. of 7 runs, 10,000,000 loops each)</code></pre>
</div>
</div>
<div id="basic-python-speed" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> standard_square(x):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit standard_square(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>204 ns ± 22.4 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</code></pre>
</div>
</div>
<p>The Numba-compiled function is a smidge faster, but we’re not breaking out the champagne just yet. But that’s expected as most of the time’s likely spent in CPython’s function call mechanism and not our tiny piece of compiled code.</p>
</section>
<section id="taking-on-the-big-leagues" class="level2">
<h2 class="anchored" data-anchor-id="taking-on-the-big-leagues">Taking on the Big Leagues</h2>
<p>Now, let’s tackle a real-world example by using Pandas and Numpy to compute a 10-period Simple Moving Average (SMA):</p>
<div id="basic-pandas-speed" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pandas_sma(df):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df.rolling(<span class="dv">10</span>).mean()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.random.rand(<span class="dv">1000</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame({<span class="st">"my_column"</span>: arr})</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>pandas_sma_result <span class="op">=</span> pandas_sma(df)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit pandas_sma(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>131 µs ± 1.77 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)</code></pre>
</div>
</div>
<div id="basic-numpy-sma-speed" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numpy_sma(a, n<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    ret <span class="op">=</span> np.cumsum(a, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    ret[n:] <span class="op">=</span> ret[n:] <span class="op">-</span> ret[:<span class="op">-</span>n]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ret[n <span class="op">-</span> <span class="dv">1</span>:] <span class="op">/</span> n</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>numpy_sma_result <span class="op">=</span> numpy_sma(arr)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numpy_sma(arr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>7.52 µs ± 66.4 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)</code></pre>
</div>
</div>
<p>We want to compare them with our own Numba-function written for the same purpose:</p>
<div id="basic-numba-sma-speed" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numba <span class="im">as</span> nb</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.njit</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numba_sma(arr):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    window <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty(arr.shape)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    out[:] <span class="op">=</span> np.nan</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(window, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        window_sum <span class="op">=</span> np.<span class="bu">sum</span>(arr[i<span class="op">-</span>window:i])</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        out[i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> window_sum <span class="op">/</span> window</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>numba_sma_result <span class="op">=</span> numba_sma(arr)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numba_sma(arr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>4.69 µs ± 22.1 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)</code></pre>
</div>
</div>
<p>But before we continue, let’s ensure that the Numba and Pandas implementations return similar results:</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>pandas_result_arr <span class="op">=</span> pandas_sma_result[<span class="st">"my_column"</span>].values</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pandas_result_arr[<span class="op">-</span><span class="dv">5</span>:])</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(numba_sma_result[<span class="op">-</span><span class="dv">5</span>:])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>np.allclose(pandas_result_arr, numba_sma_result, equal_nan<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.45720976 0.41700846 0.4315914  0.4301416  0.42904101]
[0.45720976 0.41700846 0.4315914  0.4301416  0.42904101]</code></pre>
</div>
<div id="compare-outputs" class="cell-output cell-output-display" data-execution_count="7">
<pre><code>True</code></pre>
<p>Ensure the results are the same. np.allclose is a great method for checking closeness of values in an array while ignoring small discrepancies.</p>
</div>
</div>
<p>Numba leaves Pandas in the dust, but it’s not even twice as fast Numpy. Why? Because I’m just messing with you, silly! Wakey, wakey!</p>
<p>We’re just getting started.</p>
</section>
<section id="the-need-for-speed-reloaded" class="level2">
<h2 class="anchored" data-anchor-id="the-need-for-speed-reloaded">The Need for Speed: Reloaded</h2>
<p>We will crank things up a notch and write an even faster Numba implementation. But it means stepping out of our cozy Pythonic comfort zone and diving headfirst into regular for-loops and verbose code:</p>
<div id="faster-numba-sma" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.njit</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numba_sma_faster(arr):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    window_size <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty(n)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    out[:] <span class="op">=</span> np.nan</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    accumulator <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> window_size <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>            accumulator <span class="op">+=</span> arr[i]</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>            out[i] <span class="op">=</span> np.nan</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>            accumulator <span class="op">+=</span> arr[i]</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;=</span> window_size:</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>                accumulator <span class="op">-=</span> arr[i <span class="op">-</span> window_size]</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>            out[i] <span class="op">=</span> accumulator <span class="op">/</span> window_size</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>faster_numba_sma_result <span class="op">=</span> numba_sma_faster(arr)</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numba_sma_faster(arr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>2.3 µs ± 6.09 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>np.allclose(pandas_result_arr, faster_numba_sma_result, equal_nan<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>True</code></pre>
</div>
</div>
<p>We’re using the accumulator pattern here, which is much more efficient. Instead of repeatedly accessing all items in the window to compute the sum, we maintain a running total (the accumulator) and subtract the value of the item exiting the window while adding the value of the item entering the window.</p>
<p>In traditional Python, this approach is not the best, and it would be slower than Numpy. But in Numba-land, these blasphemous for-loops can be blazing fast. This function is over 50 times faster than Pandas, over 3 times faster than Numpy, and 2 times faster than the previous Numba version. It may seem a bit unpythonic, but the results speak for themselves.</p>
</section>
<section id="nice-but-can-it-run-parallel" class="level2">
<h2 class="anchored" data-anchor-id="nice-but-can-it-run-parallel">Nice, but can it run parallel?</h2>
<p>Now, let’s dive into the world of parallelization. I mentioned earlier that the Global Interpreter Lock (GIL) in CPython can be a buzzkill when you’re trying to parallelize Python programs. But guess what? Numba, once again, comes to the rescue.</p>
<p>When we use Numba’s <code>njit</code> decorator, the code in the JIT-compiled function isn’t interpreted; it’s already compiled into machine code. This means we can sidestep the GIL entirely! In fact, Numba can even automatically parallelize array operations if you use the <code>parallel</code> keyword argument. Then you have <code>numba.prange</code>. It’s like the regular Python <code>range</code>, but with a twist. If parallelization is enabled, the loop executes in parallel. If it’s disabled, it behaves just like its standard counterpart.</p>
<p>Now, let’s put this to the test with our earlier, slightly sluggish Numba SMA function, and a much larger array since it does not make sense to spawn new threads for an operation that only takes a few microseconds in total:</p>
<div id="basic-numba-sma-speed-parallel" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.njit</span>(parallel<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numba_sma_parallel(arr):</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    window <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> np.empty(arr.shape)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>    out[:] <span class="op">=</span> np.nan</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> nb.prange(window, n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        window_sum <span class="op">=</span> np.<span class="bu">sum</span>(arr[i<span class="op">-</span>window:i])</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        out[i<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> window_sum <span class="op">/</span> window</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> out</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> np.random.rand(<span class="dv">1_000_000</span>)</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>numba_sma_parallel_result <span class="op">=</span> numba_sma_parallel(arr)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numba_sma_parallel(arr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>778 µs ± 18.4 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)</code></pre>
</div>
</div>
<p>Compare with Numpy:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>numpy_sma_result <span class="op">=</span> numpy_sma(arr)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit numpy_sma(arr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>3.39 ms ± 17.9 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>
</div>
</div>
<p>Over three times faster than the Numpy variant, with barely any changes! I’d say that’s impressive.</p>
</section>
<section id="navigating-the-numba-maze-pitfalls-to-watch-out-for" class="level2">
<h2 class="anchored" data-anchor-id="navigating-the-numba-maze-pitfalls-to-watch-out-for">Navigating the Numba Maze: Pitfalls to Watch Out For</h2>
<p>We’ve barely scratched the surface of Numba’s greatness, but before we call it a day, it’s crucial to discuss the potential pitfalls that come with the territory of working with Numba.</p>
<p>Now, if you’ve been paying attention (and I trust you have), we’ve exclusively danced with Numba’s njit decorator, which, let’s be clear, is the gold standard. <code>@njit</code> is essentially a shorthand notation for another Numba decorator, expressed as <code>@jit(nopython=True)</code>. You see, it’s like flipping a switch into what Numba aficionados call the <code>nopython</code> mode where all the code is compiled.</p>
<p>There’s also an <code>object</code> mode which Numba falls back on if Numba is unable to compile all of the code. In this mode, Numba becomes a bit of a detective, looking for loops it can convert into faster machine code. However, the rest of your code remains as interpreted Python code. If you don’t enforce <code>nopython</code> mode using <code>@njit</code> or <code>jit(nopython=True)</code>, Numba might fall back to <code>object</code> mode, log some warnings, and provide little to no performance benefits at all.</p>
<p>But there are scenarios where you’re practically forced to abandon the cozy realm of <code>nopython</code> mode, and go with <code>object</code> object mode as the second best option.</p>
<p>Look here:</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> entropy</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.njit</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> entropy_nb(probability_distribution):</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> entropy(probability_distribution, base<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Shannon entropy for a fair coin toss</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    entropy_nb(np.array([<span class="fl">0.5</span>, <span class="fl">0.5</span>]))</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> nb.TypingError <span class="im">as</span> e:</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(e)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Failed in nopython mode pipeline (step: nopython frontend)
Untyped global name 'entropy': Cannot determine Numba type of &lt;class 'function'&gt;

File "../../../../../../tmp/ipykernel_183868/4199264108.py", line 5:
&lt;source missing, REPL/exec in use?&gt;
</code></pre>
</div>
</div>
<p>That’s some ugly typing error. A lot of SciPy functions can’t be used in <code>nopython</code> mode because they are C-bindings that don’t play too well with Numba. Let’s try it without <code>nopython</code> mode enforced:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.jit</span> <span class="co"># ← Notice "jit" instead of "njit"</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> entropy_nb(probability_distribution):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> entropy(probability_distribution, base<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Shannon entropy for a fair coin toss</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>entropy_nb(np.array([<span class="fl">0.5</span>, <span class="fl">0.5</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>/tmp/ipykernel_183868/526531211.py:2: NumbaDeprecationWarning:

The 'nopython' keyword argument was not supplied to the 'numba.jit' decorator. The implicit default value for this argument is currently False, but it will be changed to True in Numba 0.59.0. See https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit for details.

/tmp/ipykernel_183868/526531211.py:1: NumbaWarning:


Compilation is falling back to object mode WITH looplifting enabled because Function "entropy_nb" failed type inference due to: Untyped global name 'entropy': Cannot determine Numba type of &lt;class 'function'&gt;

File "../../../../../../tmp/ipykernel_183868/526531211.py", line 3:
&lt;source missing, REPL/exec in use?&gt;


/home/jon/.local/lib/python3.10/site-packages/numba/core/object_mode_passes.py:151: NumbaWarning:

Function "entropy_nb" was compiled in object mode without forceobj=True.

File "../../../../../../tmp/ipykernel_183868/526531211.py", line 1:
&lt;source missing, REPL/exec in use?&gt;


/home/jon/.local/lib/python3.10/site-packages/numba/core/object_mode_passes.py:161: NumbaDeprecationWarning:


Fall-back from the nopython compilation path to the object mode compilation path has been detected. This is deprecated behaviour that will be removed in Numba 0.59.0.

For more information visit https://numba.readthedocs.io/en/stable/reference/deprecation.html#deprecation-of-object-mode-fall-back-behaviour-when-using-jit

File "../../../../../../tmp/ipykernel_183868/526531211.py", line 1:
&lt;source missing, REPL/exec in use?&gt;

</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>1.0</code></pre>
</div>
</div>
<p>Some pesky warnings pop up, Numba attempts to compile, realizes it’s in over its head, and gracefully falls back to object mode. In the end, it works as expected, but it does not exactly look pretty, does it?</p>
<p>Before we part ways, let’s heed Numba’s advice in the logged warnings and explicitly enforce <code>object</code> mode:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="at">@nb.jit</span>(forceobj<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> entropy_nb(probability_distribution):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> entropy(probability_distribution, base<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate Shannon entropy for a fair coin toss</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>entropy_nb(np.array([<span class="fl">0.5</span>, <span class="fl">0.5</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>1.0</code></pre>
</div>
</div>
<p>No warnings, no fancy compilation attempts - it just works. Of course, in this particular example, using Numba might seem a bit like bringing a rocket launcher to a thumb wrestling match, as it won’t provide any significant performance boost. But where it might shine is in a more complex function where some parts can’t be compiled, yet there are loops that could certainly benefit from Numba’s <code>nopython</code> mode.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>In conclusion, Numba is a powerful tool for enhancing the performance of Python code. Its ability to compile Python functions into machine code using JIT compilation can significantly accelerate computations. We explored its advantages, from basic usage to more complex scenarios like parallelization.</p>
<p>However, it’s essential to be aware of potential pitfalls, such as falling back to “object” mode when “nopython” mode isn’t feasible, particularly for certain external libraries or complex functions. While Numba provides an effective means to optimize Python, careful consideration of its application is necessary to maximize its benefits.</p>
<p>If this post piqued your interest, I recommend that you connect with me on <a href="https://www.linkedin.com/in/jon-mester/">LinkedIn</a> and check out Numba’s <a href="https://numba.readthedocs.io">documentation</a>. Get in touch if you have any questions.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>